package exposure

# Currently we ignore ClusterIP and NodePort services that point to ingress controllers.. what are the implications of this?
# TODO: we need better matching of selectors to labels.. right now we only have equality
# TODO: add support for multiple exposure levels (internet, intranet, and cluster)
# TODO: add support for services that point directly to pods (via deployments/daemonsets/statefulsets, etc) but we can just match the service selector to the pods
# TODO: true the schema up to what actual Services/Pods/Ingress look like.  How to actually express an IGC?  How to get the ingressClass from an Ingress controller? or do we even need to?
# TODO: add test

# The default exposure level for Pods, Services, and IngressControllers is intranet
# We dont need to assign an exposure level directly to Ingress objects, we can infer from what they point at

lb_services[service] {
  service := data.services[_]
  service.type == "LoadBalancer"
}

lb_services_with_private_ips[service] {
  service := lb_services[_]
  private_subnets := data.rfc1819_subnets[_]
  net.cidr_contains(private_subnets, service.externalIP)
}

lb_services_with_public_ips[service] {
  service := lb_services[_]
  not lb_services_with_private_ips[service]
}

violations[msg] {
  service := lb_services_with_public_ips[_]
  not service.annotations["exposure"] == "internet"
  msg := sprintf("Services with public IPs must have an annotation indicating that their exposure level is 'internet'.  service=%s/%s ipaddress=%s", [service.namespace, service.name, service.externalIP])
}

# Now we should find lb_services that point to ingress controllers.. how?  They should share a common namespace and the svc label selector should point to the igc.label.. or can we do it based on igc name?
# Find services marked internet that point to an ingress that isnt marked internet

lb_services_for_igc[ingressControllerService] {
  service := lb_services[_]
  ingressController := data.ingressControllers[_]
  service.namespace == ingressController.namespace
  # TODO: the service.selector doesnt necessarily need to EQUAL the ingressController.labels, it just needs to be a subnet of them
  # IE if the ingressController contains extra labels, this rule wont match that combination of svc/igc

  # These three lines join the service selector to the pod labels (and allows pod labels to have additional labels)
  selectorLabelSet := { { x: service.selector[x] } | service.selector[x] }
  podLabelFilteredSet := { { x: ingressController.labels[x] } | ingressController.labels[x]; ingressController.labels[x] == service.selector[x] }
  selectorLabelSet == podLabelFilteredSet

  ingressControllerService := { "ingressController": ingressController, "service": service }
}

#violations[msg] {
#  ingressControllerService := lb_services_for_igc[_]
#  service := ingressControllerService.service
#  ingressController := ingressControllerService.ingressController
#  service.annotations["exposure"] == "internet"
#  not ingressController.annotations["exposure"] == "internet"
#  msg := sprintf("Services with an exposure level of 'internet' cannot point at ingress controllers that dont have an exposure level of 'internet'.  service=%s/%s ingressController=%s/%s", [service.namespace, service.name, ingressController.namespace, ingressController.name])
#}

